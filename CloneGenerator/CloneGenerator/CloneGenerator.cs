using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CloneGenerator;

[Generator]
public class CloneGenerator : IIncrementalGenerator
{
    internal const string Namespace = "CloneGenerator";
    internal const string AttributeName = "GenerateCloneAttribute";
    internal const string IgnoreCloneAttribute = "CloneIgnoreAttribute";

    private const string AttributesSource = 
        $$"""
         // <auto-generated/>

         namespace {{Namespace}}
         {
             [System.AttributeUsage(System.AttributeTargets.Class)]
             public class {{AttributeName}} : System.Attribute
             {
             }
         
             [System.AttributeUsage(System.AttributeTargets.Property | System.AttributeTargets.Field)]
             public class {{IgnoreCloneAttribute}} : System.Attribute
             {
             }
         }
         """;

    internal const string InterfaceName = "ISourceGeneratedCloneable";
    
    internal const string CtorVariableName = "original";
    internal const string CloneMethodName = "Clone";

    private const string InterfaceSource = 
        $$"""
         // <auto-generated/>

         namespace {{Namespace}}
         {
             public interface {{InterfaceName}}<TSelf>
             {
                 TSelf {{CloneMethodName}}();
             }
         }
         """;


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(
            ctx =>
            {
                ctx.AddSource(
                    "Attributes.g.cs",
                    SourceText.From(AttributesSource, Encoding.UTF8)
                );
                ctx.AddSource(
                    $"{InterfaceName}.g.cs",
                    SourceText.From(InterfaceSource, Encoding.UTF8)
                );
            }
        );
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx)
            )
            .Where(t => t.AttributeFound)
            .Select((t, _) => t.Class);

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right)
        );
    }

    private void GenerateCode(SourceProductionContext ctx, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        var classSymbols = classDeclarations
            .Select(
                classDeclaration => compilation.GetSemanticModel(classDeclaration.SyntaxTree)
                    .GetDeclaredSymbol(classDeclaration)
            )
            .OfType<INamedTypeSymbol>()
            .ToList();

        var classesInAssemblyGeneratingClone = classSymbols
            .Select(c => $"{c.ContainingNamespace.ToDisplayString()}.{c.Name}")
            .ToImmutableHashSet();

        var context = new CloneGeneratorContext(classSymbols);
        context.Do(ctx);
    }

    private static void ResolveCloneMethod(ISymbol member, TextWriter writer, IReadOnlyCollection<string> classesInAssemblyGeneratingClone)
    {
        var syntaxNode = member.DeclaringSyntaxReferences
            .FirstOrDefault()
            ?.GetSyntax();
        switch (member, syntaxNode)
        {
            case (IFieldSymbol { CanBeReferencedByName: true, Type: INamedTypeSymbol returnType } field, _):
                writer.WriteLine($"this.{field.Name} = original.{field.Name};");
                break;
            case (IPropertySymbol { GetMethod: not null, Type: INamedTypeSymbol returnType } propertySymbol, PropertyDeclarationSyntax { AccessorList: not null }):
            {
                var returnTypeName = returnType.ToDisplayString();
                if (classesInAssemblyGeneratingClone.Contains(returnTypeName)
                    || returnType.AllInterfaces.Any(c => c.Name == InterfaceName))
                {
                    writer.WriteLine($"this.{propertySymbol.Name} = (({Namespace}.{InterfaceName}<{returnTypeName}>)original.{propertySymbol.Name}).Clone();");
                }
                else
                {
                    writer.WriteLine($"this.{propertySymbol.Name} = original.{propertySymbol.Name};");
                }

                break;
            }
            default:
                break;
        }
    }

    private static (ClassDeclarationSyntax Class, bool AttributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (var attributeSyntax in classDeclarationSyntax.AttributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            var symbol = context.SemanticModel.GetSymbolInfo(attributeSyntax)
                .Symbol;

            if (symbol is not IMethodSymbol attributeSymbol)
            {
                continue; // if we can't get the symbol, ignore it
            }

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Report] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
            {
                return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }
}